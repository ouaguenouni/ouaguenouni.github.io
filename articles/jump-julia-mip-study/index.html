<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A comprehensive study of Mixed Integer Programming with JuMP on Julia (Part 1) - Ouaguenouni Mohamed</title>
    <link rel="stylesheet" type="text/css" href="../../style.css">
    <link rel="stylesheet" type="text/css" href="../../article.css">
    <meta property="og:title" content="A comprehensive study of Mixed Integer Programming with JuMP on Julia (Part 1)">
    <meta property="og:description" content="Some basics of Linear/Mixed Integer Programming & How to use a heuristic callback inside a MIP solver.">
    <meta property="og:image" content="/articles/jump-julia-mip-study/og.png">
    <meta property="og:type" content="article">
    <meta property="twitter:card" content="summary_large_image">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
</head>
<body>
    <header class="site-header">
        <h1><a href="../../index.html">Ouaguenouni Mohamed</a></h1>
    </header>

<aside class="reading-sidebar">
    <div class="progress-wrapper">
        <div class="previous-subtitle"></div>
        <div class="current-subtitle"></div>
        <div class="next-subtitle"></div>
        <div class="progress-bar-container">
            <div class="progress-bar"></div>
        </div>
    </div>
</aside>

<article class="main-article">
    <h1 class="article-title">A comprehensive study of Mixed Integer Programming with JuMP on Julia (Part 1)</h1>
    <p class="article-meta">6 min read · Published on Mar 29, 2021</p>
    <section>
        <p>Some basics of Linear/Mixed Integer Programming &amp; How to use a heuristic callback inside a MIP solver.  </p>
<h2>Introduction</h2>
<p>One of the primary purposes of the computer sciences and operation research is to solve problems efficiently; problem-solving is a field where we often find very “ad-hoc” methods of resolution, they can be efficient, but they rely on some specific properties of the problem which are not necessarily easy to notice.</p>
<p>In this series of posts, we will introduce and discover a very versatile and generic way of thinking and of solving a wide variety of problems, and this introduction will occur on three sides:</p>
<ul>
<li>On the theoretical view, we will investigate how Linear Programming and Mixed Integer Programming can help us in modelling big combinatorial problems.</li>
<li>In the practical aspect, we will see how we can use an API to instantiate a Linear Program and exploit some of the problems we solve to improve the solving procedure's efficiency.</li>
<li>And finally, from the operational perspective, we will discover a very recent, efficient and user-friendly language: Julia, and more precisely, we will discover a library: JuMP, a domain-specific modelling language for <a href="https://en.wikipedia.org/wiki/Mathematical_optimization">mathematical optimization</a>.</li>
</ul>
<p>This series of posts doesn't assume a background in Julia; I think a Python background is more than enough to understand the pieces of code I will use.</p>
<h2>What is this post about</h2>
<p>This post is the pilot of the series, but it will also be the starting point of it by giving you the background you will need to understand the practical techniques that can be used to solve large combinatorial problems.</p>
<p>It will also be the only post in which we will present a pure theoretical academic problem as an application for simplicity.</p>
<p>Still, if you are comfortable with mixed-integer programming, this post (and more generally this series) is a good occasion to see to use Julia and, more precisely, <strong>how to tune your exact solving procedure with some approached methods</strong>.</p>
<hr />
<h2>Smooth introduction to Linear Programming (and to Julia)</h2>
<p>Let’s start by presenting how a linear program is structured and how a solver will perform a resolution. To do it, we will go through a simple example.</p>
<p>To make it visualizable, we will take an example where we will try to optimize a linear function of two variables with respect to a set of linear constraints.</p>
<p>$$

\begin{align*}
\text{max} \quad & x + 2y \\
\text{Subject to} \quad & x \leq 10.0 \\
& y \leq 7.5 \\
& x \geq 0.0 \\
& y \geq 0.0
\end{align*}

$$</p>
<p>Geometrically, if we take each constraint and replace the inequality with equality, each constraint will be a line equation. This line will separate R² into two parts and invalidate one of them according to the direction of the inequality.</p>
<p>We will name the polyhedron delimited by the set of constraints, which is, in this case, a polytope because it’s close and bounded, the polyhedron (or the polytope) of constraints.</p>
<p>As a warm-up to Julia, let’s see how we can draw the polytope of constraints by using plot.jl, a “matplotlib-like” framework and the Package LinearAlgebra is similar to NumPy.</p>
<p>First, we use Pkg, which is the built-in package manager of Julia, to add the required Packages,</p>
<pre><code class="language-julia">using Pkg;
Pkg.add(&quot;LinearAlgebra&quot;);
Pkg.add(&quot;Plots&quot;);
Pkg.add(&quot;PyPlot&quot;);
</code></pre>
<p>After adding them, we can import them.</p>
<pre><code class="language-julia">using LinearAlgebra
using Plots
pyplot()
</code></pre>
<p>The last line aims to complete some package plot functionalities for visualization (check the doc here for more details).</p>
<p>An easy way to draw any function is to sample points and compute the associated images, and this can be done in Julia the following way :</p>
<pre><code class="language-julia">x_v = LinRange(-2,15,100)
plot([x_v], [x_v .+ 7.5], label =&quot;Y=x + 7.5&quot;)
plot!([x_v], [-2x_v .+ 20], label =&quot;Y= -2x + 20&quot;)
</code></pre>
<p>The first line will sample 100 points from the interval [-2, 15]; a part of this; you have several things to notice :</p>
<ul>
<li>“plot” is used to create a line plot and plot! update a created plot.</li>
<li>“.+” is the element-wise equivalent of the vector addition.</li>
<li>Julia is so handy that omitting the “*” between a coefficient and a variable is possible even with a vector.</li>
</ul>
<p>These lines will produce the following plot :</p>
<p><img alt="plot_1" src="plot_1.webp" /></p>
<p><div class="embedded-html" id="embed-0">
<div id="chart"></div>
<script>
(function() {

    const margin = {top: 20, right: 30, bottom: 40, left: 50};
    const width = 720 - margin.left - margin.right;
    const height = 500 - margin.top - margin.bottom;

    const svg = d3.select("#chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    const xScale = d3.scaleLinear().domain([-2, 16]).range([0, width]);
    const yScale = d3.scaleLinear().domain([-10, 25]).range([height, 0]);

    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale).ticks(8));

    svg.append("g")
        .call(d3.axisLeft(yScale).ticks(7));

    svg.append("g")
        .attr("class", "grid")
        .attr("opacity", 0.1)
        .call(d3.axisLeft(yScale).tickSize(-width).tickFormat(""));

    svg.append("g")
        .attr("class", "grid")
        .attr("transform", `translate(0,${height})`)
        .attr("opacity", 0.1)
        .call(d3.axisBottom(xScale).tickSize(-height).tickFormat(""));

    const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y));

    const data1 = d3.range(-2, 16.5, 0.5).map(x => ({x, y: x + 7.5}));
    const data2 = d3.range(-2, 16.5, 0.5).map(x => ({x, y: -2*x + 20}));

    svg.append("path")
        .datum(data1)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-width", 2)
        .attr("d", line);

    svg.append("path")
        .datum(data2)
        .attr("fill", "none")
        .attr("stroke", "coral")
        .attr("stroke-width", 2)
        .attr("d", line);

    const legend = svg.append("g")
        .attr("transform", "translate(10, 380)");

    legend.append("rect")
        .attr("width", 120)
        .attr("height", 45)
        .attr("fill", "white")
        .attr("stroke", "black");

    legend.append("line")
        .attr("x1", 10).attr("x2", 40)
        .attr("y1", 15).attr("y2", 15)
        .attr("stroke", "steelblue")
        .attr("stroke-width", 2);

    legend.append("text")
        .attr("x", 45).attr("y", 19)
        .text("Y=x + 7.5")
        .attr("font-size", "12px");

    legend.append("line")
        .attr("x1", 10).attr("x2", 40)
        .attr("y1", 33).attr("y2", 33)
        .attr("stroke", "coral")
        .attr("stroke-width", 2);

    legend.append("text")
        .attr("x", 45).attr("y", 37)
        .text("Y= -2x + 20")
        .attr("font-size", "12px");

    // Add interactive overlay
    const focus = svg.append("g").style("display", "none");

    focus.append("line")
        .attr("class", "x-hover-line")
        .attr("stroke", "black")
        .attr("stroke-width", 1)
        .attr("stroke-dasharray", "3,3");

    focus.append("circle")
        .attr("class", "circle1")
        .attr("r", 5)
        .attr("fill", "steelblue");

    focus.append("circle")
        .attr("class", "circle2")
        .attr("r", 5)
        .attr("fill", "coral");

    focus.append("text")
        .attr("class", "text1")
        .attr("dx", 8)
        .attr("dy", -8)
        .attr("font-size", "12px");

    focus.append("text")
        .attr("class", "text2")
        .attr("dx", 8)
        .attr("dy", 8)
        .attr("font-size", "12px");

    svg.append("rect")
        .attr("class", "overlay")
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .on("mouseover", () => focus.style("display", null))
        .on("mouseout", () => focus.style("display", "none"))
        .on("mousemove", mousemove);

    function mousemove(event) {
        const [mx] = d3.pointer(event);
        const x = xScale.invert(mx);
        const y1 = x + 7.5;
        const y2 = -2 * x + 20;

        focus.select(".x-hover-line")
            .attr("x1", xScale(x))
            .attr("x2", xScale(x))
            .attr("y1", 0)
            .attr("y2", height);

        focus.select(".circle1")
            .attr("cx", xScale(x))
            .attr("cy", yScale(y1));

        focus.select(".circle2")
            .attr("cx", xScale(x))
            .attr("cy", yScale(y2));

        focus.select(".text1")
            .attr("x", xScale(x))
            .attr("y", yScale(y1))
            .text(`(${x.toFixed(1)}, ${y1.toFixed(1)})`);

        focus.select(".text2")
            .attr("x", xScale(x))
            .attr("y", yScale(y2))
            .text(`(${x.toFixed(1)}, ${y2.toFixed(1)})`);
    }

})();
</script>
</div></p>
<p><div class="embedded-html" id="embed-1">
<div id="chart"></div>
<script>
(function() {

    const data = [
        // First line (olive/yellow-green)
        { x: 10, y: 69, type: 'Client', group: 'line1' },
        { x: 32, y: 68, type: 'Client', group: 'line1' },

        // Second line (orange)
        { x: 14, y: 47, type: 'Client', group: 'line2' },
        { x: 32, y: 30, type: 'Depot', group: 'line2' },
        { x: 50, y: 50, type: 'Depot', group: 'line2' },

        // Third line (blue)
        { x: 35, y: 100, type: 'Client', group: 'line3' },
        { x: 42, y: 92, type: 'Client', group: 'line3' },

        // Fourth line (purple)
        { x: 56, y: 47, type: 'Client', group: 'line4' },
        { x: 76, y: 33, type: 'Client', group: 'line4' },

        // Fifth line (teal)
        { x: 67, y: 75, type: 'Client', group: 'line5' },
        { x: 76, y: 81, type: 'Client', group: 'line5' }
    ];

    const margin = { top: 20, right: 120, bottom: 40, left: 50 };
    const width = 600 - margin.left - margin.right;
    const height = 450 - margin.top - margin.bottom;

    const svg = d3.select("#chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    const xScale = d3.scaleLinear()
        .domain([10, 80])
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .domain([30, 100])
        .range([height, 0]);

    // Add grid lines
    svg.append("g")
        .attr("class", "grid")
        .attr("opacity", 0.1)
        .call(d3.axisLeft(yScale)
            .tickSize(-width)
            .tickFormat(""));

    svg.append("g")
        .attr("class", "grid")
        .attr("opacity", 0.1)
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale)
            .tickSize(-height)
            .tickFormat(""));

    // Add X axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale));

    // Add Y axis
    svg.append("g")
        .call(d3.axisLeft(yScale));

    // Group data by line
    const lineGroups = d3.group(data, d => d.group);

    // Draw lines
    const lineColors = {
        'line1': '#9ca348',
        'line2': '#d87a3f',
        'line3': '#5b7bb5',
        'line4': '#8b7bb5',
        'line5': '#4a9fb5'
    };

    lineGroups.forEach((points, group) => {
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));

        svg.append("path")
            .datum(points)
            .attr("fill", "none")
            .attr("stroke", lineColors[group])
            .attr("stroke-width", 1.5)
            .attr("d", line);
    });

    // Add points
    const colorScale = d3.scaleOrdinal()
        .domain(['Client', 'Depot'])
        .range(['#4a9fb5', '#d87a3f']);

    svg.selectAll("circle")
        .data(data)
        .enter()
        .append("circle")
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(d.y))
        .attr("r", 5)
        .attr("fill", d => colorScale(d.type))
        .attr("stroke", "white")
        .attr("stroke-width", 1.5);

    // Add legend
    const legend = svg.append("g")
        .attr("transform", `translate(${width + 20}, 20)`);

    legend.append("rect")
        .attr("class", "legend-box")
        .attr("x", -10)
        .attr("y", -10)
        .attr("width", 80)
        .attr("height", 60)
        .attr("rx", 4);

    const legendItems = [
        { label: 'Client', color: '#4a9fb5' },
        { label: 'Depot', color: '#d87a3f' }
    ];

    legendItems.forEach((item, i) => {
        const legendRow = legend.append("g")
            .attr("transform", `translate(0, ${i * 25})`);

        legendRow.append("circle")
            .attr("r", 5)
            .attr("fill", item.color)
            .attr("stroke", "white")
            .attr("stroke-width", 1.5);

        legendRow.append("text")
            .attr("x", 15)
            .attr("y", 5)
            .style("font-size", "12px")
            .text(item.label);
    });

})();
</script>
</div></p>
<p>and now let’s print the polytope of constraints :</p>
<pre><code class="language-julia">x_v = LinRange(-2,15,100)
y_v = LinRange(-2,15,100)
plot([0*x_v], [y_v],label =&quot;Y Axis&quot;)
plot!([x_v], [0*x_v],label =&quot;X Axis&quot;)
plot!([x_v], [0*x_v .+ 7.5], label =&quot;Y=7.5&quot;)
plot!([0*x_v .+ 10], [y_v],label =&quot;X=10&quot;)
plot!(title = &quot;Polytop of Constraints&quot;)
</code></pre>
<p><img alt="plot_2" src="plot_2.webp" /></p>
<p>The grey area I added to the plot represents the space's portion, which satisfies the problem's constraints.</p>
<p>Now let’s focus on the objective function by looking at the vector (1,2), representing the gradient of the linear function x+2y.</p>
<p><img alt="plot_3" src="plot_3.webp" /></p>
<p>Each line I added represents a line of points with the same value. The further you go in the gradient direction, the bigger the objective value becomes.</p>
<p>We can visually conclude that the best solution is at the intersection of the green and the pink line, so let’s see if we find this result using JuMP.</p>
<p>The traditional add/import lines (we will use GLPK as a solver, but nothing is dependant on it).</p>
<pre><code class="language-julia">Pkg.add(&quot;JuMP&quot;)
Pkg.add(&quot;GLPK&quot;)
using JuMP
using GLPK
</code></pre>
<p>Now we declare our model and set the optimizer from GLPK:</p>
<pre><code class="language-julia">prgrm = Model()
set_optimizer(prgrm, GLPK.Optimizer)
</code></pre>
<p>We add the variables and precise their scope; by default, the variables are continuous :</p>
<pre><code class="language-julia">@variable(prgrm, 0&lt;=x)
@variable(prgrm, 0&lt;=y)
</code></pre>
<p>Now we create and add the two remaining constraints; the first two are in the scope of the variables;</p>
<pre><code class="language-julia">@constraint(prgrm, x &lt;= 10)
@constraint(prgrm, y &lt;= 7.5)
</code></pre>
<p>Finally, we add the objective function and precise sense of optimization, which will be, in this case, a maximization :</p>
<pre><code class="language-julia">@objective(prgrm, Max, x+2y)
</code></pre>
<p>One interesting feature of JuMP and especially when using it with Jupyter-notebook is that we can print the program as easily as the content of any variable, which gives us the following output :</p>
<p><img alt="plot_4" src="plot_4.webp" /></p>
<p>And now solving it is as easy to say as it is to do :</p>
<pre><code class="language-julia">optimize!(prgrm)
</code></pre>
<p>After that, we can access the values of the variables after optimization like this:</p>
<pre><code class="language-julia">value.(x)
value.(y)
</code></pre>
<p>And so one we can update our precedent plot to confirm our graphical resolution with the line :</p>
<pre><code class="language-julia">plot!([value.(x)], [value.(y)], seriestype = :scatter, label=&quot;Optimum&quot;)
</code></pre>
<p>This gives us :</p>
<p><img alt="plot_5" src="plot_5.webp" /></p>
<h2>The Simplex principle</h2>
<p>Solving a linear program is done with the Simplex algorithm, which works because of a simple but important principle :</p>
<blockquote>
<p>Optimizing a linear function on a polytope (or more generally a compact convex space) always leads us to a vertex (more generally an extreme point).</p>
</blockquote>
<p>The simplex algorithm is a local search procedure that walks from a vertex to another to increase the objective function's value until we reach a vertex where every neighbour has an inferior value.</p>
<p>Since the vertex where the optimization ends depends only on the objective function, we can try to find an objective function for each polytope vertex.</p>
<p>For example, in the following polytope (Note that we added a constraint to increase the number of vertex of the polytope)</p>
<p><img alt="plot_6" src="plot_6.webp" /></p>
<p>We can obtain any of the vertices by optimizing in different directions.</p>
<p><img alt="plot_7" src="plot_7.webp" /></p>
<hr />
<h2>From Continuous to Integer variables: The Branch-and-Bound Method</h2>
<p>Even if it’s not totally how a solver works, the first thing you have to understand to assimilate how Mixed Integer Programming works is the Branch and Bound method.</p>
<p>Let’s take the precedent example but restricting our variables to integers; the feasible region is no longer the grey area inside the polytope. Still, we can compute the feasible integer points, which give us the following figure :</p>
<p><img alt="plot_8" src="plot_8.webp" /></p>
<p>In grey, we can see the feasible solutions, and the first thing we can notice is that some vertices are in the integer solutions and some not, and this distinction is crucial, but we will get back to this point later.</p>
<p>The branch and bound procedure create a tree called “enumeration tree”; in each node, it constructs a mixed-integer program and solves its “linear relaxation” with the simplex algorithm, which means the same program after ignoring integrality constraint, from this point on, there are two possible outcomes :</p>
<ul>
<li>The solution is integer feasible, and therefore we stop the resolution.</li>
</ul>
<p>This can happen if the polytope of constraints has integer vertices. For instance, if we solve the LP relaxation of the precedent mixed-integer program with the objective function 2x+y, we will find (10,3), which is an integer solution.</p>
<ul>
<li>The solution is “fractional”, and therefore we need to branch.</li>
</ul>
<p>And this will happen in the precedent polytope if we try to optimize the function x+2y,</p>
    </section>
</article>


<footer class="article-footer">
    <div class="footer-line">
        <span>O</span>
    </div>
    <p><a href="../../index.html">← Back to home</a></p>
</footer>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.24/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.24/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.24/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body, {
        delimiters: [
            {left:'$$', right:'$$', display:true},
            {left:'$', right:'$', display:false}
        ]
    });"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/julia.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
    hljs.highlightAll();
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const progressBar = document.querySelector('.progress-bar');
    const previousSubtitle = document.querySelector('.previous-subtitle');
    const currentSubtitle = document.querySelector('.current-subtitle');
    const nextSubtitle = document.querySelector('.next-subtitle');
    const headings = document.querySelectorAll('.main-article section h2, .main-article section h3');
    const articleTitleEl = document.querySelector('.main-article .article-title');
    const articleTitle = articleTitleEl.textContent;

    headings.forEach((h, i) => {
        if (!h.id) h.id = 'heading-' + i;
    });
    if (!articleTitleEl.id) articleTitleEl.id = 'article-title';

    function updateProgress() {
        const scrollTop = window.scrollY;
        const docHeight = document.body.scrollHeight - window.innerHeight;
        const scrollPercent = (scrollTop / docHeight) * 100;
        progressBar.style.height = scrollPercent + '%';

        let currentIndex = -1;
        headings.forEach((h, i) => {
            if (h.offsetTop - 50 <= scrollTop) currentIndex = i;
        });

        let current = currentIndex >= 0 ? headings[currentIndex] : null;

        if (current) {
            currentSubtitle.textContent = current.textContent;
            currentSubtitle.dataset.targetId = current.id;

            previousSubtitle.textContent = headings[currentIndex - 1]?.textContent || '';
            previousSubtitle.dataset.targetId = headings[currentIndex - 1]?.id || '';

            nextSubtitle.textContent = headings[currentIndex + 1]?.textContent || '';
            nextSubtitle.dataset.targetId = headings[currentIndex + 1]?.id || '';
        } else {
            currentSubtitle.textContent = articleTitle;
            currentSubtitle.dataset.targetId = articleTitleEl.id;

            previousSubtitle.textContent = '';
            previousSubtitle.dataset.targetId = '';

            nextSubtitle.textContent = headings[0]?.textContent || '';
            nextSubtitle.dataset.targetId = headings[0]?.id || '';
        }
    }

    function scrollToSubtitle(el) {
        const targetId = el.dataset.targetId;
        if (!targetId) return;
        const target = document.getElementById(targetId);
        if (!target) return;

        window.scrollTo({
            top: target.offsetTop,
            behavior: 'smooth'
        });

        const onScroll = () => {
            const scrollTop = window.scrollY;
            if (Math.abs(scrollTop - target.offsetTop) < 2) {
                updateProgress();
                window.removeEventListener('scroll', onScroll);
            }
        };
        window.addEventListener('scroll', onScroll);
    }

    [previousSubtitle, currentSubtitle, nextSubtitle].forEach(el => {
        el.addEventListener('click', () => scrollToSubtitle(el));
    });

    window.addEventListener('scroll', updateProgress);
    updateProgress();
});
</script>


</body>
</html>