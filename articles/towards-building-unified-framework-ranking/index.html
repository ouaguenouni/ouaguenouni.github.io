<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Towards building a unified framework for feature selection with ranking functions - Ouaguenouni Mohamed</title>
    <link rel="stylesheet" type="text/css" href="../../style.css">
    <link rel="stylesheet" type="text/css" href="../../article.css">
</head>
<body>
    <header class="site-header">
        <h1><a href="../../index.html">Ouaguenouni Mohamed</a></h1>
    </header>

<aside class="reading-sidebar">
    <div class="progress-wrapper">
        <div class="previous-subtitle"></div>
        <div class="current-subtitle"></div>
        <div class="next-subtitle"></div>
        <div class="progress-bar-container">
            <div class="progress-bar"></div>
        </div>
    </div>
</aside>


<article class="main-article">
    <h1 class="article-title">Towards building a unified framework for feature selection with ranking functions</h1>
    <p class="article-meta">2 min read · Published on Apr 7, 2021</p>
    <section>
        <p>In the feature engineering of any data related project, we often have to filter the columns we will use to train our model manually; this filtering often relies on the insights we have on data and also on many criteria that can help us distinguish between the valuable attributes and the redundant or the meaningless ones, this process is known as the <strong>feature selection</strong>.</p>
<p>They are many different ways of selecting attributes; the one we see today is known as the ranking feature selection. It’s the most basic way. It evaluates each attribute with a function, ranks them and keeps the best attributes.</p>
<p>Although this ranking can be done with various methods, we will explore these method’s classification, see how this classification can help us organize them into a reliable and extensible framework, and use this framework to test and compare their behaviours.</p>
<h2>Feature selection ranking methods</h2>
<p>In feature selection, we can classify the quality measure of an attribute into five categories according to the classification made by Dash and Liu.</p>
<ul>
<li>Distance measures: These quantify the correlation between the attributes and the label.</li>
<li>Information measures: These information theory measures are interested in the label’s entropy after splitting them according to a feature's value.</li>
<li>Consistency measures: A feature is consistent if the same values are not associated with different values of the class.</li>
<li>Dependency measures: Two variables are said to be independent if the probability of taking a specific value is not influenced by information on the other's value, so these measures work by quantifying the class's dependency on an attribute.</li>
<li>Classification measures: These measures are time expensive; they evaluate the classification quality when taking a specific attribute.</li>
</ul>
<p>I will, of course, come back to each of these classes when presenting the measures I will consider.</p>
    </section>
</article>


<footer class="article-footer">
    <div class="footer-line">
        <span>O</span>
    </div>
    <p><a href="../../index.html">← Back to home</a></p>
</footer>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.24/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.24/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.24/dist/contrib/auto-render.min.js"
    onload="renderMathInElement(document.body, {
        delimiters: [
            {left:'$$', right:'$$', display:true},
            {left:'$', right:'$', display:false}
        ]
    });"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/julia.min.js"></script>
<script>
document.addEventListener("DOMContentLoaded", (event) => {
    hljs.highlightAll();
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const progressBar = document.querySelector('.progress-bar');
    const previousSubtitle = document.querySelector('.previous-subtitle');
    const currentSubtitle = document.querySelector('.current-subtitle');
    const nextSubtitle = document.querySelector('.next-subtitle');
    const headings = document.querySelectorAll('.main-article section h2, .main-article section h3');
    const articleTitleEl = document.querySelector('.main-article .article-title');
    const articleTitle = articleTitleEl.textContent;

    // Ensure all headings have an id
    headings.forEach((h, i) => {
        if (!h.id) h.id = 'heading-' + i;
    });
    if (!articleTitleEl.id) articleTitleEl.id = 'article-title';

    function updateProgress() {
        const scrollTop = window.scrollY;
        const docHeight = document.body.scrollHeight - window.innerHeight;
        const scrollPercent = (scrollTop / docHeight) * 100;
        progressBar.style.height = scrollPercent + '%';

        // Determine current heading
        let currentIndex = -1;
        headings.forEach((h, i) => {
            if (h.offsetTop - 50 <= scrollTop) currentIndex = i;
        });

        // Current heading
        let current = currentIndex >= 0 ? headings[currentIndex] : null;

        if (current) {
            currentSubtitle.textContent = current.textContent;
            currentSubtitle.dataset.targetId = current.id;

            previousSubtitle.textContent = headings[currentIndex - 1]?.textContent || '';
            previousSubtitle.dataset.targetId = headings[currentIndex - 1]?.id || '';

            nextSubtitle.textContent = headings[currentIndex + 1]?.textContent || '';
            nextSubtitle.dataset.targetId = headings[currentIndex + 1]?.id || '';
        } else {
            // Top of article: no current heading yet
            currentSubtitle.textContent = articleTitle;
            currentSubtitle.dataset.targetId = articleTitleEl.id;

            previousSubtitle.textContent = '';
            previousSubtitle.dataset.targetId = '';

            nextSubtitle.textContent = headings[0]?.textContent || '';
            nextSubtitle.dataset.targetId = headings[0]?.id || '';
        }
    }

    function scrollToSubtitle(el) {
        const targetId = el.dataset.targetId;
        if (!targetId) return;
        const target = document.getElementById(targetId);
        if (!target) return;

        // Smooth scroll
        window.scrollTo({
            top: target.offsetTop,
            behavior: 'smooth'
        });

        // Continuously check scroll position until it reaches target
        const onScroll = () => {
            const scrollTop = window.scrollY;
            if (Math.abs(scrollTop - target.offsetTop) < 2) {
                updateProgress();
                window.removeEventListener('scroll', onScroll);
            }
        };
        window.addEventListener('scroll', onScroll);
    }

    // Add click events
    [previousSubtitle, currentSubtitle, nextSubtitle].forEach(el => {
        el.addEventListener('click', () => scrollToSubtitle(el));
    });

    window.addEventListener('scroll', updateProgress);
    updateProgress();
});
</script>


</body>
</html>